"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const chai_1 = require("chai");
const tempy_1 = __importDefault(require("tempy"));
const path_1 = require("path");
const fs_1 = require("fs");
const utils = __importStar(require("./utils"));
describe('utils', () => {
    describe('parseUrl', () => {
        it('given a url without protocol', () => {
            const url = 'foobar.com';
            chai_1.assert.deepEqual(utils.parseUrl(url), `http://${url}`);
        });
        it('given a url with a protocol', () => {
            const url = 'http://foobar.com';
            chai_1.assert.deepEqual(utils.parseUrl(url), url);
        });
    });
    describe('parseBrowser', () => {
        it('given an unknown browser returns error', () => {
            const incorrectBrowsers = [
                // Truly unknown browser strings
                'foobar',
                // Representative strings of browsers with invalid data after
                'ie-extra',
                'ff-extra',
                'safari-extra',
                'edge-extra',
                'chrome-extra',
                // Representative strings of browsers with invalid data before
                'extra-ie',
                'extra-ff',
                'extra-safari',
                'extra-edge',
                'extra-chrome'
            ];
            for (const browser of incorrectBrowsers) {
                chai_1.assert.throws(() => utils.parseBrowser(browser), Error, `Unknown browser ${browser}`);
            }
        });
        describe('with prefixes of known browsers', () => {
            const testCases = [
                ['c', 'chrome'],
                ['ch', 'chrome'],
                ['chr', 'chrome'],
                ['f', 'firefox'],
                ['g', 'firefox'],
                ['i', 'ie'],
                ['e', 'ie'], // backcompat; ideally we'd have had this return edge
                ['s', 'safari'],
                ['saf', 'safari']
            ];
            for (const [prefix, browser] of testCases) {
                it(`given ${prefix} returns ${browser}`, () => {
                    chai_1.assert.deepEqual(utils.parseBrowser(prefix), browser);
                });
            }
        });
        it('given no browser returns chrome-headless', () => {
            chai_1.assert.deepEqual(utils.parseBrowser(), 'chrome-headless');
        });
        describe('returns firefox', () => {
            const firefoxBrowsers = ['ff', 'firefox', 'gecko', 'marionette'];
            for (const firefoxBrowser of firefoxBrowsers) {
                it(`given ${firefoxBrowser} returns firefox`, () => {
                    chai_1.assert.deepEqual(utils.parseBrowser(firefoxBrowser), 'firefox');
                });
            }
        });
        describe('returns chrome', () => {
            it('given chrome returns chrome', () => {
                chai_1.assert.deepEqual(utils.parseBrowser('chrome'), 'chrome');
            });
        });
        describe('returns ie', () => {
            const ieBrowsers = [
                'ie',
                'explorer',
                'internetexplorer',
                'internet_explorer',
                'internet-explorer'
            ];
            for (const ieBrowser of ieBrowsers) {
                it(`given ${ieBrowser} returns ie`, () => {
                    chai_1.assert.deepEqual(utils.parseBrowser(ieBrowser), 'ie');
                });
            }
        });
        describe('returns safari', () => {
            it('given safari return safari', () => {
                chai_1.assert.deepEqual(utils.parseBrowser('safari'), 'safari');
            });
        });
        describe('returns edge', () => {
            const edgeBrowsers = ['edge', 'microsoftedge'];
            for (const edgeBrowser of edgeBrowsers) {
                it(`given ${edgeBrowser} returns MicrosoftEdge`, () => {
                    chai_1.assert.deepEqual(utils.parseBrowser(edgeBrowser), 'MicrosoftEdge');
                });
            }
        });
    });
    describe('getAxeSource', () => {
        describe('mock file', () => {
            function setupTree() {
                const tempDir = tempy_1.default.directory();
                const parentDirname = (0, path_1.join)(tempDir, 'node_modules', 'axe-core');
                (0, fs_1.mkdirSync)(parentDirname, { recursive: true });
                (0, fs_1.writeFileSync)((0, path_1.join)(parentDirname, 'axe.js'), 'parent');
                const cliDirname = (0, path_1.join)(tempDir, 'packages', 'cli');
                const nodeModDirname = (0, path_1.join)(cliDirname, 'node_modules', 'axe-core');
                (0, fs_1.mkdirSync)(nodeModDirname, { recursive: true });
                (0, fs_1.writeFileSync)((0, path_1.join)(nodeModDirname, 'axe.js'), 'node modules');
                const cwdDirname = (0, path_1.join)(tempDir, 'packages', 'cli', 'lib');
                (0, fs_1.mkdirSync)(cwdDirname);
                (0, fs_1.writeFileSync)((0, path_1.join)(cwdDirname, 'axe.js'), 'cwd');
                return {
                    cliDirname,
                    parentDirname,
                    nodeModDirname,
                    cwdDirname
                };
            }
            it('uses axe.js from the working directory if it exists', () => {
                const { cwdDirname } = setupTree();
                const axeSource = utils.getAxeSource(undefined, cwdDirname);
                chai_1.assert.include(axeSource, 'cwd');
            });
            it("falls back to axe-core from the working directory's node_modules if axe.js doesn't exist in the working directory", () => {
                const { cliDirname, cwdDirname } = setupTree();
                (0, fs_1.rmSync)((0, path_1.join)(cwdDirname, 'axe.js'));
                const axeSource = utils.getAxeSource(undefined, cliDirname);
                chai_1.assert.include(axeSource, 'node modules');
            });
            it("falls back to axe-core from our own package's node_modules if no working-directory based implementation exists", () => {
                const { cwdDirname, nodeModDirname } = setupTree();
                (0, fs_1.rmSync)((0, path_1.join)(cwdDirname, 'axe.js'));
                (0, fs_1.rmSync)((0, path_1.join)(nodeModDirname, 'axe.js'));
                const axeSource = utils.getAxeSource(undefined, cwdDirname);
                chai_1.assert.include(axeSource, 'parent');
            });
        });
        it('given no axe source use local source', () => {
            const axeSource = utils.getAxeSource();
            chai_1.assert.isNotNull(axeSource);
        });
        it('given invalid axe source throws error', () => {
            chai_1.assert.throws(() => utils.getAxeSource('././././'));
        });
    });
    describe('getAxeVersion', () => {
        it('given valid axe version returns only version', () => {
            chai_1.assert.deepEqual(utils.getAxeVersion(`axe.version = '4.1.1'`), '4.1.1');
        });
        it('given invalid axe version returns unknown version string', () => {
            chai_1.assert.deepEqual(utils.getAxeVersion(`axe = '4.1.1'`), 'unknown version');
        });
    });
    describe('splitList', () => {
        it('given a comma delimited string returns array', () => {
            const delimited = 'foo,bar,baz';
            const array = utils.splitList(delimited);
            chai_1.assert.isArray(array);
            chai_1.assert.deepEqual(array, ['foo', 'bar', 'baz']);
        });
        it('given a single string returns an array', () => {
            const string = 'foo';
            const array = utils.splitList(string);
            chai_1.assert.isArray(array);
            chai_1.assert.deepEqual(array, ['foo']);
        });
    });
});
//# sourceMappingURL=utils.test.js.map